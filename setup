#!/bin/zsh

# GNU Stow dotfiles management script
# This script uses GNU Stow to symlink all dotfiles from the dotfiles directory

set -e  # Exit on any error

# Capture script name for help function
SCRIPT_NAME="${0##*/}"

# Configuration
BASE_DOTFILES_DIR="$HOME/Personal/configs/dotfiles"
DOTFILES_DIR="$BASE_DOTFILES_DIR"
TARGET_DIR="$HOME"
STOW_CMD="stow"
STOW_IGNORE="--ignore='\.setup\.sh'"
PRIORITY_PACKAGES=("stow")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Prompt helper that reads from the controlling terminal, not stdin of pipelines
prompt_confirm() {
    local message="$1"
    local reply
    printf "%s [y/N] " "$message" > /dev/tty
    # Read from the terminal explicitly so prompts work inside pipelines
    read -r reply < /dev/tty
    if [[ "$reply" =~ ^[Yy](es)?$ ]]; then
        return 0
    else
        return 1
    fi
}

# Function to check if stow is installed
check_stow() {
    if ! command -v $STOW_CMD &> /dev/null; then
        print_error "GNU Stow is not installed!"
        print_status "Please install it using:"
        print_status "  macOS: brew install stow"
        print_status "  Ubuntu/Debian: sudo apt install stow"
        print_status "  CentOS/RHEL: sudo yum install stow"
        exit 1
    fi
    print_success "GNU Stow is installed"
}

# Function to check if dotfiles directory exists
check_dotfiles_dir() {
    if [ ! -d "$DOTFILES_DIR" ]; then
        print_error "Dotfiles directory not found: $DOTFILES_DIR"
        exit 1
    fi
    print_success "Dotfiles directory found: $DOTFILES_DIR"
}

# Function to get list of packages
get_packages() {
    find "$DOTFILES_DIR" -maxdepth 1 -type d -not -name ".*" -not -path "$DOTFILES_DIR" | sort
}

# Function to show help
show_help() {
    local script_name="${1:-setup.sh}"
    echo "Usage: $script_name [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  -d, --dry-run  Show what would be done without making changes"
    echo "  -c, --clean    Remove existing symlinks before stowing"
    echo "  -r, --restow   Restow packages (clean + stow)"
    echo "  -l, --list     List available packages"
    echo "  -p, --packages Stow specific packages (remaining args are package names)"
    echo "  -f, --force    Force symlinks even if files already exist"
    echo "  -y, --yes      Auto-confirm removals when using --force"
    echo "  -o, --os       Target OS: mac (default) or windows"
    echo "  --full         Also run .setup.sh scripts for packages after stowing"
    echo ""
    echo "Examples:"
    echo "  $script_name                    # Stow all packages"
    echo "  $script_name --dry-run          # Preview what would be done"
    echo "  $script_name --clean            # Remove all symlinks"
    echo "  $script_name -p git zsh         # Stow only git and zsh packages"
    echo "  $script_name --restow           # Clean and restow all packages"
    echo "  $script_name --force            # Force symlinks, prompt before removal"
    echo "  $script_name --force --yes      # Force symlinks, auto-confirm removals"
    echo "  $script_name --os windows       # Use dotfiles/windows as the source"
    echo "  $script_name -p micro --full    # Stow micro and run its .setup.sh script"
    echo "  $script_name -p micro nano w3m  # Stow multiple packages"
}

# Function to stow packages
stow_packages() {
    local packages=("$@")
    local dry_run_flag=""
    local force_flag=""
    
    if (( DRY_RUN )); then
        dry_run_flag="-n"
        print_status "DRY RUN MODE - No changes will be made"
    fi
    
    if (( FORCE )); then
        print_status "FORCE MODE - Will overwrite existing files with symlinks"
    fi
    
    if [ ${#packages[@]} -eq 0 ]; then
        packages=($(get_packages | xargs -I {} basename {}))
    fi

    # Sort packages with priority packages first
    sorted_packages=()
    remaining_packages=()
    for pkg in "${packages[@]}"; do
        if [[ " ${PRIORITY_PACKAGES[*]} " =~ " $pkg " ]]; then
            sorted_packages+=("$pkg")
        else
            remaining_packages+=("$pkg")
        fi
    done
    packages=("${sorted_packages[@]}" "${remaining_packages[@]}")

    print_status "Stowing packages: ${packages[*]}"
    
    for package in "${packages[@]}"; do
        if [ "$package" = "private" ]; then
            print_status "Skipping private package"
            continue
        fi

        local package_path="$DOTFILES_DIR/$package"
        
        if [ ! -d "$package_path" ]; then
            print_warning "Package '$package' not found, skipping..."
            continue
        fi
        
        print_status "Stowing package: $package"
        
        # If force is enabled, remove existing files/directories that would conflict
        if (( FORCE )) && (( ! DRY_RUN )); then
            remove_conflicting_files "$package"
        fi
        
        if (( DRY_RUN )); then
            $STOW_CMD $dry_run_flag $STOW_IGNORE -d "$DOTFILES_DIR" -t "$TARGET_DIR" "$package"
        else
            if $STOW_CMD $dry_run_flag $STOW_IGNORE -d "$DOTFILES_DIR" -t "$TARGET_DIR" "$package"; then
                print_success "Successfully stowed: $package"
            else
                print_error "Failed to stow: $package"
                return 1
            fi
        fi
    done
}

# Function to clean packages
clean_packages() {
    local packages=("$@")
    
    if [ ${#packages[@]} -eq 0 ]; then
        packages=($(get_packages | xargs -I {} basename {}))
    fi

    # Sort packages with priority packages first
    sorted_packages=()
    remaining_packages=()
    for pkg in "${packages[@]}"; do
        if [[ " ${PRIORITY_PACKAGES[*]} " =~ " $pkg " ]]; then
            sorted_packages+=("$pkg")
        else
            remaining_packages+=("$pkg")
        fi
    done
    packages=("${sorted_packages[@]}" "${remaining_packages[@]}")

    print_status "Cleaning packages: ${packages[*]}"
    
    for package in "${packages[@]}"; do
        local package_path="$DOTFILES_DIR/$package"
        
        if [ ! -d "$package_path" ]; then
            print_warning "Package '$package' not found, skipping..."
            continue
        fi
        
        print_status "Cleaning package: $package"
        
        if $STOW_CMD -D -d "$DOTFILES_DIR" -t "$TARGET_DIR" "$package"; then
            print_success "Successfully cleaned: $package"
        else
            print_warning "Failed to clean: $package (may not exist)"
        fi
    done
}

# Function to list packages
list_packages() {
    print_status "Available packages:"
    for package in $(get_packages | xargs -I {} basename {}); do
        echo "  - $package"
    done
}

# Function to handle private environment file
setup_private_file() {
    local private_file="$HOME/.private-env"
    local private_template="$DOTFILES_DIR/private/.private-env"
    
    # Check if file exists and is readable (not a broken symlink)
    if [ -f "$private_file" ] && [ -r "$private_file" ]; then
        print_status "$private_file file already exists"
    else
        # Remove broken symlink if it exists
        if [ -L "$private_file" ]; then
            print_status "Removing broken symlink: $private_file"
            rm "$private_file"
        fi
        
        print_status "Private file not found: $private_file"
        if [ -f "$private_template" ]; then
            print_status "Copying template $private_template file to $private_file"
            cp "$private_template" "$private_file"
            print_success "Created $private_file from template"
        else
            print_warning "Private template file not found: $private_template"
        fi
    fi
}

# Function to remove conflicting files/directories for force mode
remove_conflicting_files() {
    local package="$1"
    local package_path="$DOTFILES_DIR/$package"
    print_status "[force] Inspecting conflicts for package: $package"
    print_status "[force] Package path: $package_path"
    
    # Find all files in the package that would be stowed
    print_status "[force] Scanning files under: $package_path"
    find "$package_path" -type f | while read -r file; do
        print_status "[force:file] Consider: $file"
        # Calculate the target path by removing the package path and dotfiles path
        local relative_path="${file#$package_path/}"
        local target_path="$TARGET_DIR/$relative_path"
        print_status "[force:file] Relative path: $relative_path"
        print_status "[force:file] Target path: $target_path"
        
        # Check if target exists and is not already a symlink
        if [ -e "$target_path" ] && [ ! -L "$target_path" ]; then
            print_warning "[force:file] Target exists and is not a symlink"
            if [ "$ASSUME_YES" = 1 ]; then
                print_status "Removing conflicting file: $target_path"
                rm -rf "$target_path"
            else
                if prompt_confirm "Conflict: $target_path exists. Remove it?"; then
                    print_status "Removing conflicting file: $target_path"
                    rm -rf "$target_path"
                else
                    print_warning "Skipped removing: $target_path"
                fi
            fi
        else
            if [ -L "$target_path" ]; then
                print_status "[force:file] Target is already a symlink, skipping removal: $target_path"
            else
                print_status "[force:file] Target does not exist, no conflict: $target_path"
            fi
        fi
    done
    
    # Also check for conflicting directories
    print_status "[force] Scanning directories under: $package_path"
    find "$package_path" -type d | while read -r dir; do
        print_status "[force:dir] Consider: $dir"
        local relative_path="${dir#$package_path/}"
        local target_path="$TARGET_DIR/$relative_path"
        print_status "[force:dir] Relative path: $relative_path"
        print_status "[force:dir] Target path: $target_path"
        
        # Check if target directory exists and is not already a symlink
        if [ -d "$target_path" ] && [ ! -L "$target_path" ]; then
            # Check if directory is empty or contains only files that would be replaced
            local has_conflicts=false
            find "$target_path" -type f 2>/dev/null | while read -r existing_file; do
                local existing_relative="${existing_file#$TARGET_DIR/}"
                local package_file="$package_path/$existing_relative"
                if [ ! -f "$package_file" ]; then
                    has_conflicts=true
                    break
                fi
            done
            
            if [ "$has_conflicts" = false ]; then
                print_status "[force:dir] Directory contains only replacable files"
                if [ "$ASSUME_YES" = 1 ]; then
                    print_status "Removing conflicting directory: $target_path"
                    rm -rf "$target_path"
                else
                    if prompt_confirm "Conflict: directory $target_path exists. Remove it?"; then
                        print_status "Removing conflicting directory: $target_path"
                        rm -rf "$target_path"
                    else
                        print_warning "Skipped removing directory: $target_path"
                    fi
                fi
            else
                print_warning "[force:dir] Directory has files that are not part of package; skipping removal: $target_path"
            fi
        else
            if [ -L "$target_path" ]; then
                print_status "[force:dir] Target directory path is a symlink, skipping removal: $target_path"
            else
                print_status "[force:dir] Target directory does not exist, no conflict: $target_path"
            fi
        fi
    done
    print_success "[force] Conflict inspection complete for: $package"
}

# Main function
main() {
    # Parse command line arguments using zparseopts
    local -A opts
    local -a args
    local -a help dry_run clean restow list packages force yes os full
    
    # Define option specifications for zparseopts
    # Format: -o shortopt --longopt:description
    zparseopts -D -E -A opts -M \
        h=help -help=help \
        d=dry_run -dry-run=dry_run \
        c=clean -clean=clean \
        r=restow -restow=restow \
        l=list -list=list \
        p=packages -packages=packages \
        f=force -force=force \
        y=yes -yes=yes \
        o:=os -os:=os \
        -full=full
    
    # Check for help option
    if (( ${#help[@]} > 0 )); then
        show_help "$SCRIPT_NAME"
        exit 0
    fi
    
    # Set boolean flags based on parsed options
    DRY_RUN=$(( ${#dry_run[@]} > 0 ))
    CLEAN=$(( ${#clean[@]} > 0 ))
    RESTOW=$(( ${#restow[@]} > 0 ))
    LIST=$(( ${#list[@]} > 0 ))
    FORCE=$(( ${#force[@]} > 0 ))
    ASSUME_YES=$(( ${#yes[@]} > 0 ))
    FULL=$(( ${#full[@]} > 0 ))
    
    # Extract package names if -p flag is provided
    SPECIFIC_PACKAGES=()
    PACKAGE_MODE=$(( ${#packages[@]} > 0 ))
    if (( PACKAGE_MODE )); then
        # Remaining arguments after zparseopts are the package names
        SPECIFIC_PACKAGES=("$@")
        set --  # Clear positional parameters since we've consumed them
    fi

    # Resolve OS selection (default: mac)
    SELECTED_OS="mac"
    if (( ${#os[@]} > 0 )); then
        SELECTED_OS="${os[2]}"
    fi
    case "$SELECTED_OS" in
        mac|windows)
            ;;
        *)
            print_error "Invalid --os value: $SELECTED_OS (expected 'mac' or 'windows')"
            exit 1
            ;;
    esac
    DOTFILES_DIR="$BASE_DOTFILES_DIR/$SELECTED_OS"
    print_status "Using OS: $SELECTED_OS"
    print_status "Dotfiles dir: $DOTFILES_DIR"
    
    # Check for unknown arguments
    if (( $# > 0 )); then
        print_error "Unknown arguments: $*"
        show_help
        exit 1
    fi
    
    # Check prerequisites
    check_stow
    check_dotfiles_dir
    
    # Setup private file (always run this, but respect dry run)
    if (( ! DRY_RUN )); then
        setup_private_file
    fi

    # Function to run .setup.sh scripts for packages
    run_setup_scripts() {
        local packages=("$@")

        if [ ${#packages[@]} -eq 0 ]; then
            packages=($(get_packages | xargs -I {} basename {}))
        fi

        for package in "${packages[@]}"; do
            local setup_script="$DOTFILES_DIR/$package/.setup.sh"

            if [ -f "$setup_script" ]; then
                print_status "Running setup script for: $package"
                if (( DRY_RUN )); then
                    print_status "DRY RUN: Would run: zsh $setup_script"
                else
                    if (cd "$DOTFILES_DIR/$package" && zsh .setup.sh); then
                        print_success "Successfully ran setup script for: $package"
                    else
                        print_error "Failed to run setup script for: $package"
                        return 1
                    fi
                fi
            fi
        done
    }
    
    # Handle different modes
    if (( LIST )); then
        list_packages
        exit 0
    fi
    
    if (( CLEAN )); then
        if (( ${#SPECIFIC_PACKAGES[@]} > 0 )); then
            clean_packages "${SPECIFIC_PACKAGES[@]}"
        else
            clean_packages
        fi
        exit 0
    fi

    if (( RESTOW )); then
        print_status "Restowing packages (clean + stow)"
        if (( ${#SPECIFIC_PACKAGES[@]} > 0 )); then
            clean_packages "${SPECIFIC_PACKAGES[@]}"
            stow_packages "${SPECIFIC_PACKAGES[@]}"
            if (( FULL )); then
                run_setup_scripts "${SPECIFIC_PACKAGES[@]}"
            fi
        else
            clean_packages
            stow_packages
            if (( FULL )); then
                run_setup_scripts
            fi
        fi
        exit 0
    fi

    # Default: stow packages
    if (( ${#SPECIFIC_PACKAGES[@]} > 0 )); then
        stow_packages "${SPECIFIC_PACKAGES[@]}"
        if (( FULL )); then
            run_setup_scripts "${SPECIFIC_PACKAGES[@]}"
        fi
    else
        stow_packages
        if (( FULL )); then
            run_setup_scripts
        fi
    fi
    
    print_success "Dotfiles setup complete!"
}

# Run main function with all arguments
main "$@"
